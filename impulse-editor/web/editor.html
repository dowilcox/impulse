<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { width: 100%; height: 100%; overflow: hidden; background: transparent; }
  #container { width: 100%; height: 100%; }
  #loading {
    display: flex; align-items: center; justify-content: center;
    width: 100%; height: 100%; color: inherit; opacity: 0.4; font-family: monospace; font-size: 14px;
  }
</style>
</head>
<body>
<div id="loading">Loading editor...</div>
<div id="container" style="display:none;"></div>

<script src="vs/loader.js"></script>
<script>
"use strict";

// ---------------------------------------------------------------------------
// Platform-abstracted host communication
// ---------------------------------------------------------------------------
function sendToHost(msgObj) {
  const json = JSON.stringify(msgObj);
  if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.impulse) {
    window.webkit.messageHandlers.impulse.postMessage(json);
  }
}

// ---------------------------------------------------------------------------
// State
// ---------------------------------------------------------------------------
let editor = null;
let currentModel = null;
let currentFilePath = "";
let requestSeq = 0;
const pendingCompletions = new Map();
const pendingHovers = new Map();
let contentChangeTimer = null;
let contentVersion = 0;

// ---------------------------------------------------------------------------
// Monaco initialization
// ---------------------------------------------------------------------------
require.config({
  paths: { vs: "./vs" }
});

// Configure web workers â€” use document.baseURI so file:// paths resolve correctly
window.MonacoEnvironment = {
  getWorker: function (moduleId, label) {
    var baseUri = document.baseURI.substring(0, document.baseURI.lastIndexOf("/") + 1);
    var workerUrl = baseUri + "vs/base/worker/workerMain.js";
    var blob = new Blob(
      ["self.MonacoEnvironment={baseUrl:'" + baseUri + "'};importScripts('" + workerUrl + "');"],
      { type: "application/javascript" }
    );
    return new Worker(URL.createObjectURL(blob));
  },
};

require(["vs/editor/editor.main"], function () {
  document.getElementById("loading").style.display = "none";
  document.getElementById("container").style.display = "block";

  editor = monaco.editor.create(document.getElementById("container"), {
    value: "",
    language: "plaintext",
    theme: "vs-dark",
    automaticLayout: true,
    minimap: { enabled: false },
    scrollBeyondLastLine: false,
    fontSize: 14,
    fontFamily: "'JetBrains Mono', 'Fira Code', 'Cascadia Code', monospace",
    fontLigatures: true,
    renderWhitespace: "selection",
    bracketPairColorization: { enabled: true },
    guides: { bracketPairs: true, indentation: true },
    smoothScrolling: false,
    mouseWheelScrollSensitivity: 1,
    cursorBlinking: "smooth",
    cursorSmoothCaretAnimation: "on",
    stickyScroll: { enabled: false },
    padding: { top: 4 },
    suggest: {
      showIcons: true,
      showStatusBar: true,
      preview: true,
      shareSuggestSelections: true,
    },
    hover: { delay: 300 },
    folding: true,
    foldingStrategy: "auto",
    showFoldingControls: "mouseover",
    lineNumbers: "on",
    glyphMargin: false,
    wordWrap: "off",
    tabSize: 4,
    insertSpaces: true,
    formatOnPaste: false,
    formatOnType: false,
  });

  // --- Content change listener (debounced) ---
  editor.onDidChangeModelContent(function () {
    contentVersion++;
    if (contentChangeTimer) clearTimeout(contentChangeTimer);
    contentChangeTimer = setTimeout(function () {
      sendToHost({
        type: "ContentChanged",
        content: editor.getValue(),
        version: contentVersion,
      });
    }, 300);
  });

  // --- Cursor change listener ---
  editor.onDidChangeCursorPosition(function (e) {
    sendToHost({
      type: "CursorMoved",
      line: e.position.lineNumber,
      column: e.position.column,
    });
  });

  // --- Focus listeners ---
  editor.onDidFocusEditorText(function () {
    sendToHost({ type: "FocusChanged", focused: true });
  });
  editor.onDidBlurEditorText(function () {
    sendToHost({ type: "FocusChanged", focused: false });
  });

  // --- Ctrl+S keybinding ---
  editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS, function () {
    sendToHost({ type: "SaveRequested" });
  });

  // --- Register LSP Completion Provider ---
  monaco.languages.registerCompletionItemProvider("*", {
    triggerCharacters: [".", ":", "<", '"', "/", "@", "\\", " "],
    provideCompletionItems: function (model, position) {
      const id = ++requestSeq;
      sendToHost({
        type: "CompletionRequested",
        request_id: id,
        line: position.lineNumber - 1,
        character: position.column - 1,
      });
      return new Promise(function (resolve) {
        pendingCompletions.set(id, resolve);
        setTimeout(function () {
          if (pendingCompletions.has(id)) {
            pendingCompletions.delete(id);
            resolve({ suggestions: [] });
          }
        }, 5000);
      });
    },
  });

  // --- Register LSP Hover Provider ---
  monaco.languages.registerHoverProvider("*", {
    provideHover: function (model, position) {
      const id = ++requestSeq;
      sendToHost({
        type: "HoverRequested",
        request_id: id,
        line: position.lineNumber - 1,
        character: position.column - 1,
      });
      return new Promise(function (resolve) {
        pendingHovers.set(id, resolve);
        setTimeout(function () {
          if (pendingHovers.has(id)) {
            pendingHovers.delete(id);
            resolve(null);
          }
        }, 5000);
      });
    },
  });

  // --- Register LSP Definition Provider ---
  monaco.languages.registerDefinitionProvider("*", {
    provideDefinition: function (model, position) {
      sendToHost({
        type: "DefinitionRequested",
        line: position.lineNumber - 1,
        character: position.column - 1,
      });
      return null;
    },
  });

  // Signal ready
  sendToHost({ type: "Ready" });
});

// ---------------------------------------------------------------------------
// Command handler: called from Rust via evaluate_javascript
// ---------------------------------------------------------------------------
window.impulseReceiveCommand = function (jsonString) {
  let cmd;
  try {
    cmd = JSON.parse(jsonString);
  } catch (e) {
    console.error("Failed to parse command:", e);
    return;
  }

  if (!editor) {
    console.warn("Editor not ready, queuing command:", cmd.type);
    return;
  }

  switch (cmd.type) {
    case "OpenFile":
      handleOpenFile(cmd);
      break;
    case "SetTheme":
      handleSetTheme(cmd);
      break;
    case "UpdateSettings":
      handleUpdateSettings(cmd);
      break;
    case "ApplyDiagnostics":
      handleApplyDiagnostics(cmd);
      break;
    case "ResolveCompletions":
      handleResolveCompletions(cmd);
      break;
    case "ResolveHover":
      handleResolveHover(cmd);
      break;
    case "GoToPosition":
      handleGoToPosition(cmd);
      break;
    case "SetReadOnly":
      editor.updateOptions({ readOnly: cmd.read_only });
      break;
    default:
      console.warn("Unknown command:", cmd.type);
  }
};

// ---------------------------------------------------------------------------
// Command implementations
// ---------------------------------------------------------------------------

function handleOpenFile(cmd) {
  currentFilePath = cmd.file_path || "";
  const language = cmd.language || "plaintext";

  // Dispose old model if it exists
  if (currentModel) {
    currentModel.dispose();
  }

  const uri = monaco.Uri.parse("file://" + currentFilePath);
  currentModel = monaco.editor.createModel(cmd.content || "", language, uri);
  editor.setModel(currentModel);
  contentVersion = 0;

  // Reset undo stack by setting the model fresh
  editor.focus();
}

function handleSetTheme(cmd) {
  const theme = cmd.theme;
  if (!theme) return;

  monaco.editor.defineTheme("impulse-theme", {
    base: theme.base || "vs-dark",
    inherit: theme.inherit !== false,
    rules: (theme.rules || []).map(function (r) {
      const rule = { token: r.token };
      if (r.foreground) rule.foreground = r.foreground;
      if (r.font_style) rule.fontStyle = r.font_style;
      return rule;
    }),
    colors: theme.colors || {},
  });
  monaco.editor.setTheme("impulse-theme");
}

function handleUpdateSettings(cmd) {
  const opts = cmd.options || {};
  const update = {};
  if (opts.font_size != null) update.fontSize = opts.font_size;
  if (opts.font_family != null) update.fontFamily = opts.font_family;
  if (opts.tab_size != null) update.tabSize = opts.tab_size;
  if (opts.insert_spaces != null) update.insertSpaces = opts.insert_spaces;
  if (opts.word_wrap != null) update.wordWrap = opts.word_wrap;
  if (opts.minimap_enabled != null) update.minimap = { enabled: opts.minimap_enabled };
  if (opts.line_numbers != null) update.lineNumbers = opts.line_numbers;
  if (opts.render_whitespace != null) update.renderWhitespace = opts.render_whitespace;
  if (opts.render_line_highlight != null) update.renderLineHighlight = opts.render_line_highlight;
  if (opts.rulers != null) update.rulers = opts.rulers;
  editor.updateOptions(update);

  // Also update model options if tab settings changed
  if (currentModel && (opts.tab_size != null || opts.insert_spaces != null)) {
    currentModel.updateOptions({
      tabSize: opts.tab_size || currentModel.getOptions().tabSize,
      insertSpaces: opts.insert_spaces != null ? opts.insert_spaces : currentModel.getOptions().insertSpaces,
    });
  }
}

function handleApplyDiagnostics(cmd) {
  if (!currentModel) return;
  const markers = (cmd.markers || []).map(function (m) {
    return {
      severity: m.severity,
      startLineNumber: m.start_line + 1,
      startColumn: m.start_column + 1,
      endLineNumber: m.end_line + 1,
      endColumn: m.end_column + 1,
      message: m.message,
      source: m.source || "lsp",
    };
  });
  monaco.editor.setModelMarkers(currentModel, "lsp", markers);
}

function handleResolveCompletions(cmd) {
  const resolve = pendingCompletions.get(cmd.request_id);
  if (!resolve) return;
  pendingCompletions.delete(cmd.request_id);

  const suggestions = (cmd.items || []).map(function (item) {
    const suggestion = {
      label: item.label,
      kind: item.kind,
      insertText: item.insert_text || item.label,
      detail: item.detail || "",
    };
    if (item.insert_text_rules) {
      suggestion.insertTextRules = item.insert_text_rules;
    }
    if (item.range) {
      suggestion.range = {
        startLineNumber: item.range.start_line + 1,
        startColumn: item.range.start_column + 1,
        endLineNumber: item.range.end_line + 1,
        endColumn: item.range.end_column + 1,
      };
    }
    if (item.additional_text_edits && item.additional_text_edits.length > 0) {
      suggestion.additionalTextEdits = item.additional_text_edits.map(function (edit) {
        return {
          range: {
            startLineNumber: edit.range.start_line + 1,
            startColumn: edit.range.start_column + 1,
            endLineNumber: edit.range.end_line + 1,
            endColumn: edit.range.end_column + 1,
          },
          text: edit.text,
        };
      });
    }
    return suggestion;
  });

  resolve({ suggestions: suggestions });
}

function handleResolveHover(cmd) {
  const resolve = pendingHovers.get(cmd.request_id);
  if (!resolve) return;
  pendingHovers.delete(cmd.request_id);

  const contents = (cmd.contents || []).map(function (c) {
    return { value: c.value, isTrusted: c.is_trusted || false };
  });

  if (contents.length === 0) {
    resolve(null);
  } else {
    resolve({ contents: contents });
  }
}

function handleGoToPosition(cmd) {
  const line = (cmd.line || 0) + 1;
  const column = (cmd.column || 0) + 1;
  editor.setPosition({ lineNumber: line, column: column });
  editor.revealPositionInCenter({ lineNumber: line, column: column });
  editor.focus();
}
</script>
</body>
</html>
